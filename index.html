<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ZAC-MAN: Operations Edition</title>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        :root {
            --zalando-orange: #ff6900;
            --wall-color: #2c3e50; /* Blu scuro */
            --bg-color: #111;
            --text-color: #fff;
        }

        body {
            background-color: #222;
            color: var(--text-color);
            font-family: 'Press Start 2P', cursive;
            margin: 0;
            padding: 0;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            touch-action: none; /* Disabilita zoom su doppio tocco */
        }

        #game-container {
            position: relative;
            width: 100vmin; /* Quadrato basato sul lato più corto */
            height: 100vmin;
            max-width: 800px;
            max-height: 800px;
            background: #000;
            border: 4px solid var(--zalando-orange);
            box-shadow: 0 0 20px rgba(255, 105, 0, 0.5);
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        /* UI OVERLAY (Menu, Messaggi) */
        .overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            z-index: 10;
            padding: 20px;
        }

        .hidden { display: none !important; }

        h1 { color: var(--zalando-orange); font-size: 3rem; margin-bottom: 10px; text-shadow: 4px 4px #fff; }
        h2 { font-size: 1.5rem; color: #00ffff; margin-bottom: 20px; }
        p { line-height: 1.5; font-size: 0.8rem; color: #ccc; margin-bottom: 30px; max-width: 600px; }
        
        button {
            background: var(--zalando-orange);
            border: none;
            padding: 15px 30px;
            font-family: 'Press Start 2P';
            font-size: 1rem;
            cursor: pointer;
            color: #000;
            transition: transform 0.1s;
        }
        button:active { transform: scale(0.95); }

        /* Mobile Controls */
        #mobile-controls {
            position: absolute;
            bottom: 20px;
            width: 100%;
            display: none; /* Attivato via JS se mobile */
            justify-content: center;
            gap: 20px;
            z-index: 5;
            pointer-events: none; /* Lascia passare i click al canvas se necessario */
        }
        .d-pad-btn {
            pointer-events: auto;
            width: 60px;
            height: 60px;
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid white;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            user-select: none;
        }
        .d-pad-btn:active { background: rgba(255, 105, 0, 0.5); }

        /* Scanline effect */
        .scanlines {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.25) 50%), linear-gradient(90deg, rgba(255, 0, 0, 0.06), rgba(0, 255, 0, 0.02), rgba(0, 0, 255, 0.06));
            background-size: 100% 2px, 3px 100%;
            pointer-events: none;
            z-index: 20;
        }
    </style>
</head>
<body>

<div id="game-container">
    <canvas id="gameCanvas" width="600" height="600"></canvas>
    <div class="scanlines"></div>

    <!-- START SCREEN -->
    <div id="start-screen" class="overlay">
        <h1 style="font-size: 4vw;">ZAC-MAN</h1>
        <p>OPERATIONS EDITION</p>
        <div style="margin: 20px;">
            <img src="zally.png" onerror="this.src='data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxMDAgMTAwIj48Y2lyY2xlIGN4PSI1MCIgY3k9IjUwIiByPSI0MCIgZmlsbD0iI2ZmNjkwMCIvPjwvc3ZnPg=='" style="width: 80px; height: 80px; border-radius: 50%; animation: bounce 1s infinite alternate;">
        </div>
        <p>I documenti Ops sono ovunque!<br>Aiuta Zally a "mangiare" le fonti per caricarle su NotebookLM.</p>
        <button onclick="startGame()">START GAME</button>
        <p style="margin-top:20px; font-size: 0.6rem; color:#666;">USA LE FRECCE PER MUOVERTI</p>
    </div>

    <!-- LEVEL COMPLETE SCREEN -->
    <div id="level-screen" class="overlay hidden">
        <h2 id="level-title">LEVEL CLEARED!</h2>
        <p id="level-msg">Sources ingested.</p>
        <div id="notebook-visual" style="border: 2px dashed #00ffff; padding: 20px; margin-bottom: 20px; color: #00ffff;">
            Analyzing...
        </div>
        <button onclick="nextLevel()">NEXT LEVEL</button>
    </div>

    <!-- GAME OVER SCREEN -->
    <div id="gameover-screen" class="overlay hidden">
        <h1 style="color: red;">GAME OVER</h1>
        <p>Troppi documenti!<br>Hai perso il focus.</p>
        <button onclick="location.reload()">TRY AGAIN</button>
    </div>
    
    <!-- VICTORY SCREEN -->
    <div id="victory-screen" class="overlay hidden">
        <h1 style="color: #00ffff;">YOU WIN!</h1>
        <p>Hai domato il caos operativo con NotebookLM.</p>
        <p>Ora sei pronto per usare le tue skill nel lavoro quotidiano.</p>
        <button onclick="location.reload()">REPLAY</button>
    </div>

    <!-- MOBILE CONTROLS -->
    <div id="mobile-controls">
        <div class="d-pad-btn" ontouchstart="handleTouch('up')" onmousedown="handleTouch('up')">▲</div>
        <div style="display:flex; gap:60px;">
            <div class="d-pad-btn" ontouchstart="handleTouch('left')" onmousedown="handleTouch('left')">◀</div>
            <div class="d-pad-btn" ontouchstart="handleTouch('right')" onmousedown="handleTouch('right')">▶</div>
        </div>
        <div class="d-pad-btn" ontouchstart="handleTouch('down')" onmousedown="handleTouch('down')">▼</div>
    </div>
</div>

<script>
/**
 * ZAC-MAN GAME ENGINE
 * Un clone semplificato di Pac-Man
 */

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

// --- GAME STATE ---
let gameState = 'start'; // start, playing, level_transition, gameover, victory
let currentLevel = 1;
let score = 0;
let animationId;

// --- CONFIG ---
const TILE_SIZE = 30; // Dimensione griglia base (sarà scalata)
const COLS = 20;
const ROWS = 20;
let SCALE = 1; // Fattore di scala dinamico

// --- ASSETS ---
// Immagini generate via codice (SVG data URI) se non presenti
const zallyImg = new Image();
zallyImg.src = 'zally.png'; // Proverà a caricare zally.png
// Fallback se l'immagine non c'è: disegneremo un cerchio nel render

// --- MAPPA (1 = Muro, 0 = Vuoto) ---
// Una mappa semplice simmetrica
const mapDesign = [
    [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
    [1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1],
    [1,0,1,1,1,0,1,1,0,1,0,1,1,0,1,1,1,0,0,1],
    [1,0,1,1,1,0,1,1,0,1,0,1,1,0,1,1,1,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,1,1,0,1,0,1,1,1,1,1,1,0,1,0,1,1,0,1],
    [1,0,0,0,0,1,0,0,0,1,0,0,0,0,1,0,0,0,0,1],
    [1,1,1,1,0,1,1,1,0,1,0,1,1,1,1,0,1,1,1,1],
    [1,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,1],
    [1,0,1,1,0,1,0,1,1,0,0,1,0,1,0,1,1,0,0,1], // Centro (Box Fantasmi sarebbe qui)
    [1,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,1,1,0,1,0,1,1,1,1,1,1,0,1,0,1,1,0,1],
    [1,0,0,1,0,1,0,0,0,1,0,0,0,0,1,0,1,0,0,1],
    [1,1,0,1,0,1,1,1,0,1,0,1,1,1,1,0,1,0,1,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,1,1,1,0,1,1,0,1,0,1,1,0,1,1,1,0,0,1],
    [1,0,0,0,1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],
    [1,1,1,0,1,0,1,1,1,1,1,1,1,0,1,0,1,1,1,1],
    [1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1],
    [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
];

// --- ENTITIES ---
let player = { x: 1, y: 1, dirX: 0, dirY: 0, nextDirX: 0, nextDirY: 0, speed: 0.15, angle: 0 };
let ghosts = [];

// Tipi di fantasmi (Fonti)
const GHOST_TYPES = [
    { name: "PDF", color: "#e74c3c", label: "PDF" },
    { name: "DOC", color: "#3498db", label: "DOC" },
    { name: "WEB", color: "#2ecc71", label: "WEB" },
    { name: "MAIL", color: "#f1c40f", label: "@" }
];

function initLevel(level) {
    // Reset player
    player.x = 1;
    player.y = 1;
    player.dirX = 0; 
    player.dirY = 0;
    player.nextDirX = 0;
    player.nextDirY = 0;

    // Create ghosts based on level
    ghosts = [];
    let count = 2 + level; // Livello 1 = 3 fantasmi, Livello 2 = 4, ecc.
    
    // Trova posizioni libere per i fantasmi
    for (let i = 0; i < count; i++) {
        let placed = false;
        while (!placed) {
            let rx = Math.floor(Math.random() * COLS);
            let ry = Math.floor(Math.random() * ROWS);
            // Non spawnare troppo vicino al player o sui muri
            if (mapDesign[ry][rx] === 0 && (Math.abs(rx - player.x) > 5 || Math.abs(ry - player.y) > 5)) {
                let type = GHOST_TYPES[i % GHOST_TYPES.length];
                ghosts.push({
                    x: rx, 
                    y: ry, 
                    type: type,
                    dirX: 0,
                    dirY: 0,
                    speed: 0.08 + (level * 0.01), // Più veloci ogni livello
                    targetX: rx, // Per movimento fluido
                    targetY: ry
                });
                placed = true;
            }
        }
    }
}

// --- CONTROLS ---
window.addEventListener('keydown', (e) => {
    if (gameState !== 'playing') return;
    switch(e.key) {
        case 'ArrowUp': player.nextDirX = 0; player.nextDirY = -1; break;
        case 'ArrowDown': player.nextDirX = 0; player.nextDirY = 1; break;
        case 'ArrowLeft': player.nextDirX = -1; player.nextDirY = 0; break;
        case 'ArrowRight': player.nextDirX = 1; player.nextDirY = 0; break;
    }
});

function handleTouch(dir) {
    if (gameState !== 'playing') return;
    if (dir === 'up') { player.nextDirX = 0; player.nextDirY = -1; }
    if (dir === 'down') { player.nextDirX = 0; player.nextDirY = 1; }
    if (dir === 'left') { player.nextDirX = -1; player.nextDirY = 0; }
    if (dir === 'right') { player.nextDirX = 1; player.nextDirY = 0; }
}

// --- GAME LOGIC ---

function isWall(x, y) {
    // Gestione bordi array
    if (y < 0 || y >= ROWS || x < 0 || x >= COLS) return true;
    return mapDesign[Math.floor(y)][Math.floor(x)] === 1;
}

function update() {
    if (gameState !== 'playing') return;

    // 1. PLAYER MOVEMENT
    // Allineamento alla griglia per girare
    const centerX = Math.floor(player.x + 0.5);
    const centerY = Math.floor(player.y + 0.5);
    const dist = Math.abs(player.x - centerX) + Math.abs(player.y - centerY);

    // Se siamo "quasi" al centro della casella, possiamo cambiare direzione
    if (dist < 0.1) {
        // Prova a prendere la nuova direzione
        if (player.nextDirX !== 0 || player.nextDirY !== 0) {
            if (!isWall(centerX + player.nextDirX, centerY + player.nextDirY)) {
                player.x = centerX;
                player.y = centerY;
                player.dirX = player.nextDirX;
                player.dirY = player.nextDirY;
                player.nextDirX = 0;
                player.nextDirY = 0;
            }
        }
        // Se andiamo contro un muro, fermati
        if (isWall(centerX + player.dirX, centerY + player.dirY)) {
            player.dirX = 0;
            player.dirY = 0;
        }
    }

    player.x += player.dirX * player.speed;
    player.y += player.dirY * player.speed;

    // Rotazione visiva
    if (player.dirX === 1) player.angle = 0;
    if (player.dirX === -1) player.angle = Math.PI;
    if (player.dirY === -1) player.angle = -Math.PI/2;
    if (player.dirY === 1) player.angle = Math.PI/2;


    // 2. GHOST MOVEMENT (Random Wandering)
    ghosts.forEach(ghost => {
        // Movimento semplificato: se sei al centro, scegli direzione random valida
        const gCenterX = Math.floor(ghost.x + 0.5);
        const gCenterY = Math.floor(ghost.y + 0.5);
        const gDist = Math.abs(ghost.x - gCenterX) + Math.abs(ghost.y - gCenterY);

        if (gDist < 0.1) {
            ghost.x = gCenterX; // Snap
            ghost.y = gCenterY;

            // Scegli direzione: 80% mantieni, 20% cambia, o cambia se muro
            let possibleDirs = [];
            if (!isWall(ghost.x+1, ghost.y)) possibleDirs.push({x:1, y:0});
            if (!isWall(ghost.x-1, ghost.y)) possibleDirs.push({x:-1, y:0});
            if (!isWall(ghost.x, ghost.y+1)) possibleDirs.push({x:0, y:1});
            if (!isWall(ghost.x, ghost.y-1)) possibleDirs.push({x:0, y:-1});

            // Evita inversione a U se possibile
            const filteredDirs = possibleDirs.filter(d => d.x !== -ghost.dirX || d.y !== -ghost.dirY);
            
            if (filteredDirs.length > 0 && Math.random() > 0.1) {
                // Scegli tra quelle non inverse
                const choice = filteredDirs[Math.floor(Math.random() * filteredDirs.length)];
                ghost.dirX = choice.x;
                ghost.dirY = choice.y;
            } else if (possibleDirs.length > 0) {
                 // Scegli a caso
                const choice = possibleDirs[Math.floor(Math.random() * possibleDirs.length)];
                ghost.dirX = choice.x;
                ghost.dirY = choice.y;
            }
        }
        
        // Fuga da Zally? No, in questa versione Zally li insegue, loro vagano.
        // Se volessimo farli scappare: calcolare vettore opposto al player.
        
        ghost.x += ghost.dirX * ghost.speed;
        ghost.y += ghost.dirY * ghost.speed;
    });


    // 3. COLLISION (Eating Ghosts)
    for (let i = ghosts.length - 1; i >= 0; i--) {
        const g = ghosts[i];
        const dx = player.x - g.x;
        const dy = player.y - g.y;
        if (Math.sqrt(dx*dx + dy*dy) < 0.8) {
            // EAT GHOST
            ghosts.splice(i, 1);
            score += 100;
        }
    }

    // 4. LEVEL CLEAR
    if (ghosts.length === 0) {
        endLevel();
    }
}

// --- RENDER ---
function draw() {
    // Clear
    ctx.fillStyle = "#000";
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    const ts = canvas.width / COLS; // Tile size reale

    // Draw Map
    ctx.fillStyle = "var(--wall-color)"; // Muri
    for (let y = 0; y < ROWS; y++) {
        for (let x = 0; x < COLS; x++) {
            if (mapDesign[y][x] === 1) {
                // Disegno muri un po' più carini (con bordo)
                ctx.fillStyle = "#223";
                ctx.fillRect(x * ts, y * ts, ts, ts);
                ctx.strokeStyle = "#00ffff";
                ctx.lineWidth = 1;
                ctx.strokeRect(x * ts + 4, y * ts + 4, ts - 8, ts - 8);
            } else {
                // Dots? No, i puntini sono i fantasmi in questo gioco
                // ctx.fillStyle = "#333";
                // ctx.fillRect(x * ts + ts/2 - 1, y * ts + ts/2 - 1, 2, 2);
            }
        }
    }

    // Draw Ghosts (Sources)
    ghosts.forEach(g => {
        const gx = g.x * ts + ts/2;
        const gy = g.y * ts + ts/2;
        
        ctx.fillStyle = g.type.color;
        
        // Ghost shape body
        ctx.beginPath();
        ctx.arc(gx, gy - 2, ts * 0.4, Math.PI, 0, false);
        ctx.lineTo(gx + ts*0.4, gy + ts*0.4);
        ctx.lineTo(gx - ts*0.4, gy + ts*0.4);
        ctx.fill();

        // Label
        ctx.fillStyle = "black";
        ctx.font = `${ts*0.3}px Arial`;
        ctx.textAlign = "center";
        ctx.fillText(g.type.label, gx, gy + 2);
    });

    // Draw Player (Zally)
    const px = player.x * ts + ts/2;
    const py = player.y * ts + ts/2;

    ctx.save();
    ctx.translate(px, py);
    ctx.rotate(player.angle);
    
    // Disegna Zally (o Pacman se img fallisce)
    // Qui disegno sempre Pacman giallo/arancione per sicurezza
    ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--zalando-orange');
    ctx.beginPath();
    // Bocca che si apre/chiude basata sul tempo
    const mouth = Math.abs(Math.sin(Date.now() / 100)) * 0.2 + 0.05;
    ctx.arc(0, 0, ts * 0.45, mouth * Math.PI, (2 - mouth) * Math.PI);
    ctx.lineTo(0, 0);
    ctx.fill();

    // Se vogliamo l'immagine sopra (sperimentale)
    // ctx.drawImage(zallyImg, -ts/2, -ts/2, ts, ts);

    ctx.restore();

    requestAnimationFrame(draw);
}

// --- GAME LOOP ---
function loop() {
    update();
    // Draw è chiamato separatamente da requestAnimationFrame ma sincronizziamo
}

setInterval(loop, 1000/60); // 60 FPS Logic update
requestAnimationFrame(draw);


// --- STATE MANAGEMENT ---

function startGame() {
    document.getElementById('start-screen').classList.add('hidden');
    // Check if mobile
    if('ontouchstart' in window) {
        document.getElementById('mobile-controls').style.display = 'flex';
    }
    
    currentLevel = 1;
    gameState = 'playing';
    initLevel(1);
}

function endLevel() {
    gameState = 'level_transition';
    const screen = document.getElementById('level-screen');
    const title = document.getElementById('level-title');
    const msg = document.getElementById('level-msg');
    const note = document.getElementById('notebook-visual');

    screen.classList.remove('hidden');

    if (currentLevel === 1) {
        title.innerHTML = "INGESTION COMPLETE";
        msg.innerHTML = "Zally ha raccolto tutte le fonti.<br>Ora sono nel sistema.";
        note.innerHTML = "Generating summary...";
    } else if (currentLevel === 2) {
        title.innerHTML = "KNOWLEDGE SYNTHESIZED";
        msg.innerHTML = "Hai creato una sintesi perfetta dalle fonti confuse.";
        note.innerHTML = "Creating Q&A Chat...";
    } else if (currentLevel === 3) {
        title.innerHTML = "AUDIO READY";
        msg.innerHTML = "Hai trasformato il testo in un Podcast.";
        note.innerHTML = "Playing Audio Overview...";
    }
}

function nextLevel() {
    document.getElementById('level-screen').classList.add('hidden');
    currentLevel++;
    
    if (currentLevel > 3) {
        winGame();
    } else {
        gameState = 'playing';
        initLevel(currentLevel);
    }
}

function winGame() {
    gameState = 'victory';
    document.getElementById('victory-screen').classList.remove('hidden');
}

</script>
</body>
</html>
